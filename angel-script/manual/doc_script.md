# The script language reference
<!--TODO: check text and add links -->
Документация по скриптовому языку `AngelScript`

## Глобальные сущности (Global entities)

Все глобальные объявления разделяют одно пространство имен, поэтому их имена не должны повторяться.  
Сюда входят расширенные типы данных и встроенные функции, зарегистрированные приложением.  
Так же все определения видны всем: вызываемая функция не обязательно должна быть объявлена перед вызывающей.

### functions

Глобальные функции - именованные участки кода, принимающие параметры и возвращающие результат

```angelscript
void foo()
{
    // do something
}
```

### variables

Глобальные переменные могут быть определены в скриптах, которые будут общими для всех контекстов выполнения, имеющих доступ к скриптовому модулю.

Переменные объявленные глобально(как в примере) доступны из всех функций. Значение переменной инициализируется на этапе компиляции и любые изменения сохраняются между вызовами(are maintained between calls). Если переменная ссылается на какие нибудь ресурсы(`string` например), то они будут освобождены при удалении(`discard`) модуля либо при сбросе(`reset`) скриптового движка.

```angelscript
int MyValue = 0;
const uint MyFlag1 = 0x01;
```

Переменные примитивных(простых) типов инициализируются перед составными переменными(объекты классов). Это позволяет конструкторам классов получать корректные начальные значения глобальных переменных.  
Особым случаем является доступ к другой глобальной переменной имеющей составной тип. В этом случае нет гарантий в каком порядке инициализации, что может привести к выбросу `null-pointer exception`.

Будьте осторожны с инициализацией глобальных переменных с помощью функций, которые могут использовать другие глобальные переменные. Компилятор пытается определить порядок инициализации, но не всегда это возможно.  
Использование в функции неинициализированной глобальной переменной приведет к неопределённому поведению либо к `null-pointer exception`.

### virtual properties

Виртуальные свойства похожи на обычные переменные/свойства объектов, но имеют специальное поведение для доступа на чтение и/или запись значений. Обычно их используют в классах, но так же возможно определить их глобально.

```angelscript
int prop
{
    get { return getSomeValue(); }
    set { setSomeValue(value); }
}
```

### script classes

Классы обычно используются для объединения данных(свойств) и некоторого поведения(методов).  
Может существовать множество объектов класса, каждый из которых хранит свои данные.

```angelscript
class Foo()
{
    void bar() { value++; }
    int value;
}
```

### interfaces

Интерфейс чем то похож "контракт" - классы, реализующие интерфейс, обязуются предоставить реализацию всех методов, объявленных в интерфейсе.  
Это позволяет использовать полиморфизм и вместо конкретных классов указывать, что функции нужен объект, реализующий интерфейс.  
При этом внутри функции можно вызывать все методы интерфейса без знания, какой же конкретный тип у объекта.

```angelscript
// The interface declaration
interface MyInterface
{
    void DoSomething();
}

// A class that implements the interface MyInterface
class MyClass: MyInterface
{
    void DoSomething()
    {
        // implementation
    }
}
```

Классы могут реализовывать по несколько интерфейсов: просто перечислите нужные через запятую.

### mixin class

Множественное наследование не поддерживается, но в некоторых случаях нужно реализовать идентичный код в нескольких классах. Если это необходимо, то для исключения написания одного и того же кода в разных местах рекомендуется использовать "миксины"("примеси", "mixin classes").

Миксины позволяют вынести часть структуры класса и включать код во множество классов. Сами по себе миксины не являются самостоятельными типами и их экземпляры не могут быть созданы.

Когда миксин включается в объявление класса, все свойства и методы, определенные в "mixin class", автоматически "копируются" в этот класс.

```angelscript
mixin class MyMixin
{
    void SomeMethod() { property++; }
    int property;
}

class MyClass: MyMixin
{
    int OtherMethod()
    {
        SomeMethod();
        return property;
    }
}
```

Свойства и методы, явно определенные в классе, не будут включены снова. Таким образом, "миксин" может предоставлять реализацию "по умолчанию", а классы переопределять её.

Код "миксинов" компилируется в контексте класса, в который они включены. Тем самым "миксин" может ссылаться на сущности, которые не объявлены в нем самом.

```angelscript
mixin class MyMixin
{
    void MethodA() { print("Default"); }
    void MethodB() { property++; }
}

class MyClass: MyMixin
{
    // override method
    void MethodA() { print("Override") }

    // declare property that used by MyMixin
    int property;
}
```

При наследовании методы из "mixin class" переопределяют методы из базового класса как будто определены в производном классе. С другой стороны свойства из "миксинов" не копируются, если в базовом классе уже есть свойства с такими именами.

```angelscript
class MyBase
{
    void MethodA() { print("Base"); }
    int property;
}

mixin class MyMixin
{
    void MethodA() { print("Mixin"); }
    float property;
}

// we got:
// 'property' from base class
// 'MethodA' from mixin class
class MyClass: MyBase, MyMixin
{}
```

Миксин может содержать в объявлении список интерфейсов. В этом случае часть методов может быть реализована в самом миксине, а часть в том классе, куда миксин подключается.

Миксины не могут быть "наследниками" других классов.

```angelscript
interface I
{
    void a();
    void b();
}

mixin class MyMixin: I
{
    void a() { print("mixin implementation"); }

    // leave b() do not implemented
}

class MyClass: MyMixin
{
    // a() from MyMixin

    void b() { print("class implementation"); }
}
```

### enums

Enum("перечисление") - удобный способ создания списка именованных констант, которые могут быть использованы вместо числовых значений.  
Использование перечислений повышает читаемость кода, так как имя константы лучше передает смысл, чем простое число.

Не смотря на то, что "enum" - список валидных значений, Вы не можете быть уверены, что в переменной всегда значения из этого списка. Всегда предоставляйте "default case" на случай неизвестных значений.

Значения перечислений объявляются списком в "enum statement". Если значение не задано, то присваивается предыдущая константа + 1. Первой константе задается 0, если значение не задано явно.

```angelscript
enum MyEnum
{
    eValue0, // == 0
    eValue2 = 2,
    eValue3, // == prev + 1 == 3
    eValue200 = eValue2 * 100
}
```

### funcdefs

`funcdef` используется для создания указателей на функции задания сигнатуры этих функций.  
В указателе может быть так же сохранен указатель на объект.  
В дальнейшем указатель на функцию может быть использован так же как и обычная функция.

```angelscript
// define function signature
funcdef bool CallBack(int, int);
```

### typedefs

`typedef` используется для создания "псевдонимов" типов.

На данный момент поддерживаются только примитивные типы.

```angelscript
typedef float  real32;
typedef double real64;
```

### namespaces

Пространства имен("namespace") используются для организации больших проектов в логические модули, что может упростить понимание и запоминание структуры.  
При использовании "namespace" так же нет необходимости волноваться о пересечении имен с другими частями проекта, использующих другое пространство имен.

```angelscript
namespace A
{
    // сущности в одном namespace могут обращаться к друг другу
    void function() { variable++; }
    int variable;
}

namespace B
{
    // можно переиспользовать имена из других namespace
    // для доступа к именам из других используется scope operator(::)
    void function() { A::function(); }
}
```

Обратите внимание, что для ссылки на объект из другого пространства имен необходимо использовать оператор области видимости, за исключением случаев, когда это родительское пространство имен.  
Это необходимо только в том случае, если дочернее пространство имен объявляет тот же объект.

```angelscript

int var;
namespace Parent
{
    int var;
    namespace Child
    {
        int var;
        void func()
        {
            // Accessing variable in parent namespace requires 
            // specifying the scope if an entity in a child namespace
            // uses the same name
            var = Parent::var;

            // To access variables in global scope the scoping 
            // operator without any name should be used
            Parent::var = ::var;
        }
    }
}

void func()
{
    // Access variable in a nested namespace requires 
    // fully qualified scope specifier
    int var = Parent::Child::var;
}
```

### imports

В некоторых случаях бывает полезно динамически подгружать модули без повторной компиляции основного скрипта, при этом позволить различным модулям взаимодействовать друг с другом.  
В этом случае скрипт может импортировать функции из других модулей.  
Это достигается использованием ключевого слова `import` с последующей сигнатурой функции и указанием имени модуля, от куда будет функция импортирована.

Это позволяет компилировать скрипты, использующие imported-functions, которые недоступны на момент компиляции. Приложение может предоставить(bind) их позже, а так же отвязать их.

В случае вызова неподключенной функции скрипт будет аварийно остановлен с выбросом исключения.

```angelscript
import void MyFunction(int a, int b) from "another module";
```

## Инструкции (Statements)

### variable declarations

```angelscript
int var = 0, var2 = 10;
object@ handle, handle2;
const float pi = 3.121592f;
```

Переменные должны быть определены до использования в блоке кода или подблоках. Если код выходит из блока где переменная определена, то эта переменная становится невалидной для дальнейшего использования.

Переменная может быть определена как с так и без инициализации. Если используется инициализация, то тип результата должен быть совместим с типом переменной.

На одной строке может быть объявлено любое количество переменных, разделенных запятой. В этом случае все переменные будут одного типа.

Переменные могут быть объявлены как `const`. После инициализации у них нельзя будет изменить значение.

Переменные простых(примитивных) типов, объявленные без инициализации, будут иметь случайное значение.  
Переменные составных типов будут инициализированы значением "по умолчанию": Handles - null, у объектов вызван `default constructor`.

### expression statement
```angelscript
a = b; // assignment
func(); // function call
```
Любое выражение может быть расположено на отдельной строке как `statement`. Обычно это присвоение значений или вызов функции.

Все `expression statement` должны оканчиваться `;`


### conditions: if / if-else / switch


`if` используется для определения, что выполнять в зависимости от условия, которое должно всегда преобразовываться в `true`("истина") или `false`("ложь").

Есть возможность создания цепочек `if-else`, тогда каждое из условий будет последовательно проверяться до первого `true`.

```angelscript
if ( condition )
{
    // do something if condition is true
}

if (value < 10)
{
    // выполняется при value меньше 10
}
else
{
    // выполняется при условии, что value больше либо равно 10
}

```

Когда у Вас целочисленное выражение(знаковое или беззнаковое), которое определяет путь выполнения программы, то лучшим выбором для построения условия будет выражение `switch-case`. В случае когда все условия зависят от чисел это будет намного производительнее цепочки `if-else`.

Каждый `case` должен завершаться `break`, кроме тех случаев, когда Вам нужно перейти к следующему `case`.

```angelscript
switch (value)
{
    case 0:
        // value == 0
        break;
    case 2:
    case some_constant:
        // value == 2 or value == some_constant
        break;
    default:
        // any other cases
}
```

Значения в `case` могут быть константными переменными, значение которых определено на этапе компиляции.

### loops: while / do-while / for

```angelscript
// цикл с предусловием
int i = 0;
while (i < 10)
{
    // тело цикла
    i++;
}

// цикл с постусловием
int j = 0;
do
{
    // тело цикла
    j++;
}
while (j < 10);
```
Оба цикла `while`/`do-while` определяют, продолжать ли выполнение, вычисляя логическое условие. Если оно преобразуется в `true`, то цикл продолжается с начала. Иначе выполнение цикла останавливается и продолжается со следующего выражения, следующего за циклом.

```angelscript
// более компактный вариант цикла с предусловием
for (int n = 0; n < 10; n++)
{
    // тело цикла
}
```

`for` - специальная форма цикла `while`.  
Первая часть (до первой `;`) - инициализация - выполняется только один раз перед стартом цикла. Здесь можно расположить объявления переменных, которые будут видны только внутри цикла.  
Вторая часть - условие, определяющее, продолжать ли выполнение.  
Последняя часть выполняется после тела цикла. Используется, например, для инкремента переменной.

В блоке инициализации через запятую может быть перечислено несколько переменных.  
Так же возможно выполнение нескольких действий в последней части - так же перечислите их через запятую.

### loop control: break / continue

```angelscript
for (;;)
{
    // какой то код

    // прервать выполнение по условию
    if (condition)
        break;
}
```
`break` прекращает наиболее близкий вложенный цикл или `switch`

```angelscript
for (int n = 0; n < 10; n++)
{
    // общий код

    if (n == 5)
        continue; // пропустить обработку
    
    // для всех n, кроме 5
}
```
`continue` переходит к выполнению следующей итерации наиболее близкого вложенного цикла.

### return statement

```angelscript
int valueOfLife()
{
    return 42; // return value
}
```

Любая функция, тип возвращаемого значения которой отличается от `void`, должна завершаться с выражением `return`, которое вычисляется в тот же тип данных что и у функции.  
Функции с типом `void` могут использовать `return` для раннего прекращения выполнения.

### statement blocks

```angelscript
{
    int a;
    float b;

    {
        float a; // "скрываем" внешнее определение

        b = a; // другие внешние переменные видны
    }
    // a снова видна как int
}
```

`statement block` - блок кода - список программных инструкций(`statement`).  
Каждый блок имеет собственную область видимости, так что переменные, объявленные внутри блока, не видны снаружи.

### try-catch blocks

```angelscript
{
    try
    {
        mayThrownException();
        // может не выполниться в случае исключения
    }
    catch
    {
        // выполнится, если исключение будет выброшено
    }
}
```

Блок `try-catch` может быть использован обработки исключений в случае если Вы предпочитаете продолжение выполнения скрипта вместо аварийной остановки.

Исключения могут возникнуть в разных ситуациях: обращение к `null-pointer`, деление на ноль, быть выброшено из API приложения или самим скриптом.

## Выражения (Expressions)

### Assignments

```angelscript
lvalue = rvalue
```

`lvalue` должно быть выражением, которое вычисляется в ячейку памяти, где может быть сохранен результат вычислений, например переменной. Результат присваивания имеет тот же тип и то же значение, что и сохраняемые данные. Выражение справа всегда вычисляется перед выражением слева.

### Function call

```angelscript
func();
func(arg);
func(arg1, arg2);
lvalue = func();
```

Функции вызываются для выполнения каких либо действий и часто возвращают результат вычислений, который может быть использован в дальнейшем.  
Если функция принимает более одного аргумента, то они вычисляются в обратном порядке, то есть последний вычисляется первым.

Некоторые функции используют параметры вида "output reference" для возврата нескольких значений. При использовании подобных функций выходные параметры нужно заполнить выражениями, которые смогут сохранить значение. Для игнорирования выходного параметра следует указать специальное значение `void`.

```angelscript
// функция, возвращающая результат через out reference
void func(int &out value)
{
    value = 42;
}

// использование lvalue для получения значения
int value;
func(value);

// вызов функции игнорируя результат
func(void);
```

Возможно использование "именованных" аргументов. Именованные параметры могут передаваться в любом порядке. Неименованные параметры не могут следовать за именованными.

```angelscript
void func(int flagA = false, int flagB = false, int flagC = false) {}

// вызов функции с установкой только части параметров
func(flagC: true);
func(flagB: true, flagA: true);
```

### Math operators

```angelscript
c = -(a + b)
```

|оператор|описание|lhs|rhs|результат|
|:--:|:---------|:-:|:-:|:-:|
| +  |унарный + | - |NUM|NUM|
| -  |унарный - | - |NUM|NUM|
| +  |сложение  |NUM|NUM|NUM|
| -  |вычитание |NUM|NUM|NUM|
| *  |умножение |NUM|NUM|NUM|
| /  |деление   |NUM|NUM|NUM|
| %  |остаток   |NUM|NUM|NUM|
| ** |степень   |NUM|NUM|NUM|

Плюс и минус могут быть использованы как унарные операторы. NUM может быть любым арифметическим типом(например `int` или`float`). Оба аргумента парной операции неявно преобразуются к одному типу. Результат всегда имеет тот же тип что и параметры. Исключением является унарный минус - эта операция не определена для `uint`

### Bitwise operators

```angelscript
c = ~(a | b)
```

|оператор|описание|lhs|rhs|результат|
|:----:|:---------|:-:|:-:|:-:|
|   ~  |bitwise complement| - |NUM|NUM|
|   &  |bitwise and|NUM|NUM|NUM|
|&#124;|bitwise or |NUM|NUM|NUM|
| ^    |bitwise xor|NUM|NUM|NUM|
| <<   |left shift |NUM|NUM|NUM|
| >>   |right shift|NUM|NUM|NUM|
| >>>  |arithmetic right shift|NUM|NUM|NUM|

 Все операторы - парные, за исключением `~`.

 перед операцией оба параметра могут быть конвертированы в `integer` для сохранения знака оригинальных типов. Результат всегда того же типа, что и `lhs`

### Compound assignments

```angelscript
lvalue += rvalue;
lvalue = lvalue + rvalue;
```
Составное присвоение - это комбинация оператора с последующим присваиванием. Два выражения выше по сути одно и то же.  
Разница - первое быстрее, так как вычисляется один раз, что может иметь значение, когда `lvalue` сложное выражение.

Доступные операторы: `+=`, `-=`, `*=`, `/=`, `%=`, `**=`, `&=`, `|=`, `^=`, `<<=`, `>>=`, `>>>=`.

### Logic operators

```angelscript
if (a and b or not c)
{
    // ...
}
```

|оператор|описание|lhs|rhs|результат|
|:-:|:---------|:--:|:--:|:--:|
|not|logical not|-|bool|bool|
|and|logical and|bool|bool|bool|
|or |logical or |bool|bool|bool|
|xor|logical exclusive or|bool|bool|bool|

Булевские операторы вычисляют только необходимые выражения. Например в `a and b` выражение `b` вычисляется только при `a == true`.

Каждый логический оператор может быть записан символами: `||` - `or`, `&&` - `and`, `^^` - `xor`, `!` - `not`.

### Equality comparison operators
```angelscript
if (a == b)
{
    // ...
}
```

Операторы `==` и `!=` применяются для сравнения значений - "равно" и "не равно", соответственно. Результат всегда `boolean`.

### Relational comparison operators
```angelscript
if (a > b)
{
    // ...
}
```

Операторы `<`, `>`, `<=` и `>=` используются для сравнения значений и определения их порядка.  Результат всегда `boolean`.

### Identity comparison operators
```angelscript
if (a is null)
{
    // ...
}
else if (a is b)
{
    // ...
}
```

Операторы `is` и `!is` применяются для сравнения идентичности двух объектов, то есть являются они одним и тем же или нет. Эти операторы применимы только к ссылочным типам, так как сравнивают адреса двух объектов.  Результат всегда `boolean`.

### Increment operators
```angelscript
// a = i; i = i + 1;
a = i++;

// i = i - 1; b = i;
b = --i;
```

Эти операторы могут помещены либо до, либо после `lvalue` для увеличения/уменьшения значения. В зависимости от положения оператора в выражении используется либо оригинальное либо измененное значение. Данные операторы всегда увеличивают/уменьшают значение на 1.

### Indexing operator
```angelscript
arr[i] = 1;
```
 
 Используется для доступу к элементу, содержащемуся в объекте. В зависимости от назначения объекта выражение внутри `[]` может быть разных типов.

### Conditional expression
```angelscript
choose ? a : b
```
Если `choose == true` выражение вернет `a`, иначе `b`.

`a` и `b` должны быть одного типа. Иначе компилятор попытается неявно преобразовать значения по принципу "минимальной стоимости". То есть будет преобразовано то выражение, чья конвертация "обойдется дешевле". Расчет "стоимости преобразования" описан в "Выбор перегрузки функции".

В случае отсутствия подходящих преобразований компилятор выдаст ошибку.

Условное выражение так же может быть использовано в качестве `lvalue`, если `a` и `b` одного типа:

```angelscript
int a, b;
(condition? a: b) = 42;
```

### Member access
```angelscript
object.property = 1;
object.method();
```

Выражение `object` должно вычисляться в тип, имеющий члены. `property` - имя свойства, которое можно прочитать/записать напрямую, а `method` - имя метода, который может быть вызвана для этого объекта.

### Handle-of
```angelscript
// создание ссылки на экземпляр объекта
@handle = @object;

// освобождение ссылки
@handle = null;
```

 "Object handle" - ссылки на объект. На один экземпляр объекта может указывать несколько ссылок. Объект будет уничтожен только тогда, когда на него перестанут ссылаться все `handle`.

 Члены объекта доступны по ссылке таким же образом, как и через сам объект - через `оператор .`.

 see also: object handles.

### Parenthesis
```angelscript
a = c * (a + b);

if ((a or b) and c)
{
    // ...
}
```

"оператор скобки" используется для объединения выражений, когда приоритет операторов не дает нужного порядка вычислений.

### Scope resolution
```angelscript
int value;
void func()
{
    int value; // локальная переменная, скрывающая глобальную
    ::value = value; // используя scope operator можно сослаться на глобальную переменную.
}
```

Используя scope resolution operator (`::`) можно обращаться к переменным и функциям, чьё имя скрыто локальными сущностями. Для этого слева укажите название пространства имен(или пустую строку в случае глобального), а справа нужное имя переменной или функции.

### Type conversions
```angelscript
// неявное преобразование ссылки
intf @a = @clss();

// явное преобразование ссылки
clss @b = cast<clss>(b);
```

Для преобразования `object handle` из одного типа в другой используется `cast operator`. Если объект действительно реализует запрошенный интерфейс/класс оператор вернет валидную ссылку. В противном случае - `null`.

В обоих приведенных случаях использовался `reference cast`, применимый только к `object handle`. В этом случае хэндл ссылается на тот же объект, но с другим доступным интерфейсом.

Типы, не поддерживающие `object handles`, могут быть конвертированы с использованием `value cast`. При этом будет создано новое значение, а в случае объектов - новый экземпляр класса.

```angelscript
// неявное преобразование значения
int a = 1.0f;

// явное преобразование значения
float b = float(a)/2;
```

В большинстве случаев явный `cast` не обязателен, поскольку компилятор может выполнить неявное преобразование к нужному типу.

### Anonymous objects
Анонимные объекты(объекты созданные без объявления переменной) могут быть созданы вызовом конструктора как обычной функции. Такое создание поддерживают как ссылочные так и типы-значения.
```angelscript
// вызов функции с новым объектом MyClass
func(MyClass(1, 2, 3));
```

Анонимные объекты могут созданы с использованием списка инициализации(для типов поддерживающие их).
```angelscript
  // Call the function with a dictionary, explicitly informing the type of the initialization list
  func(dictionary = {{'banana',1}, {'apple',2}, {'orange',3}});

  // When there is only one possible type that support initialization lists it is possible  
  // to omit the type and let the compiler implicitly determine it based on the use
  funcExpectsAnArrayOfInts({1,2,3,4});

```

## Типы данных (Data types)

## Функции (Functions)

## Классы (Script classes)

## Хэндлы объектов (Object handles)

## Общие сущности (Shared script entities)

## Приоритет операторов (Operator precedence)

## Зарезервированные ключевые слова и токены(Reserved keywords and tokens)

## Грамматика скриптового языка (Script language grammar)

## Стандартная библиотека (Standard library)