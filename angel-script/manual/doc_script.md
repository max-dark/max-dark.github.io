# The script language reference

Документация по скриптовому языку `AngelScript`

## Глобальные сущности (Global entities)

Все глобальные объявления разделяют одно пространство имен, поэтому их имена не должны повторяться.  
Сюда входят расширенные типы данных и встроенные функции, зарегистрированные приложением.  
Так же все определения видны всем: вызываемая функция не обязательно должна быть объявлена перед вызывающей.

### functions

Глобальные функции - именованные участки кода, принимающие параметры и возвращающие результат

```angelscript
void foo()
{
    // do something
}
```

### variables

Глобальные переменные могут быть определены в скриптах, которые будут общими для всех контекстов выполнения, имеющих доступ к скриптовому модулю.

Переменные объявленные глобально(как в примере) доступны из всех функций. Значение переменной инициализируется на этапе компиляции и любые изменения сохраняются между вызовами(are maintained between calls). Если переменная ссылается на какие нибудь ресурсы(`string` например), то они будут освобождены при удалении(`discard`) модуля либо при сбросе(`reset`) скриптового движка.

```angelscript
int MyValue = 0;
const uint MyFlag1 = 0x01;
```

Переменные примитивных(простых) типов инициализируются перед составными переменными(объекты классов). Это позволяет конструкторам классов получать корректные начальные значения глобальных переменных.  
Особым случаем является доступ к другой глобальной переменной имеющей составной тип. В этом случае нет гарантий в каком порядке инициализации, что может привести к выбросу `null-pointer exception`.

Будьте осторожны с инициализацией глобальных переменных с помощью функций, которые могут использовать другие глобальные переменные. Компилятор пытается определить порядок инициализации, но не всегда это возможно.  
Использование в функции неинициализированной глобальной переменной приведет к неопределённому поведению либо к `null-pointer exception`.

### virtual properties

Виртуальные свойства похожи на обычные переменные/свойства объектов, но имеют специальное поведение для доступа на чтение и/или запись значений. Обычно их используют в классах, но так же возможно определить их глобально.

```angelscript
int prop
{
    get { return getSomeValue(); }
    set { setSomeValue(value); }
}
```

### script classes

Классы обычно используются для объединения данных(свойств) и некоторого поведения(методов).  
Может существовать множество объектов класса, каждый из которых хранит свои данные.

```angelscript
class Foo()
{
    void bar() { value++; }
    int value;
}
```

### interfaces

Интерфейс чем то похож "контракт" - классы, реализующие интерфейс, обязуются предоставить реализацию всех методов, объявленных в интерфейсе.  
Это позволяет использовать полиморфизм и вместо конкретных классов указывать, что функции нужен объект, реализующий интерфейс.  
При этом внутри функции можно вызывать все методы интерфейса без знания, какой же конкретный тип у объекта.

```angelscript
// The interface declaration
interface MyInterface
{
    void DoSomething();
}

// A class that implements the interface MyInterface
class MyClass: MyInterface
{
    void DoSomething()
    {
        // implementation
    }
}
```

Классы могут реализовывать по несколько интерфейсов: просто перечислите нужные через запятую.

### mixin class

Множественное наследование не поддерживается, но в некоторых случаях нужно реализовать идентичный код в нескольких классах. Если это необходимо, то для исключения написания одного и того же кода в разных местах рекомендуется использовать "миксины"("примеси", "mixin classes").

Миксины позволяют вынести часть структуры класса и включать код во множество классов. Сами по себе миксины не являются самостоятельными типами и их экземпляры не могут быть созданы.

Когда миксин включается в объявление класса, все свойства и методы, определенные в "mixin class", автоматически "копируются" в этот класс.

```angelscript
mixin class MyMixin
{
    void SomeMethod() { property++; }
    int property;
}

class MyClass: MyMixin
{
    int OtherMethod()
    {
        SomeMethod();
        return property;
    }
}
```

Свойства и методы, явно определенные в классе, не будут включены снова. Таким образом, "миксин" может предоставлять реализацию "по умолчанию", а классы переопределять её.

Код "миксинов" компилируется в контексте класса, в который они включены. Тем самым "миксин" может ссылаться на сущности, которые не объявлены в нем самом.

```angelscript
mixin class MyMixin
{
    void MethodA() { print("Default"); }
    void MethodB() { property++; }
}

class MyClass: MyMixin
{
    // override method
    void MethodA() { print("Override") }

    // declare property that used by MyMixin
    int property;
}
```

При наследовании методы из "mixin class" переопределяют методы из базового класса как будто определены в производном классе. С другой стороны свойства из "миксинов" не копируются, если в базовом классе уже есть свойства с такими именами.

```angelscript
class MyBase
{
    void MethodA() { print("Base"); }
    int property;
}

mixin class MyMixin
{
    void MethodA() { print("Mixin"); }
    float property;
}

// we got:
// 'property' from base class
// 'MethodA' from mixin class
class MyClass: MyBase, MyMixin
{}
```

Миксин может содержать в объявлении список интерфейсов. В этом случае часть методов может быть реализована в самом миксине, а часть в том классе, куда миксин подключается.

Миксины не могут быть "наследниками" других классов.

```angelscript
interface I
{
    void a();
    void b();
}

mixin class MyMixin: I
{
    void a() { print("mixin implementation"); }

    // leave b() do not implemented
}

class MyClass: MyMixin
{
    // a() from MyMixin

    void b() { print("class implementation"); }
}
```

### funcdefs
### typedefs
### namespaces
### imports

## Инструкции (Statements)

## Выражения (Expressions)

## Типы данных (Data types)

## Функции (Functions)

## Классы (Script classes)

## Хэндлы объектов (Object handles)

## Общие сущности (Shared script entities)

## Приоритет операторов (Operator precedence)

## Зарезервированные ключевые слова и токены(Reserved keywords and tokens)

## Грамматика скриптового языка (Script language grammar)

## Стандартная библиотека (Standard library)